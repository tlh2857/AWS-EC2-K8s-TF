
# Terraform Template: EC2 with Kubernetes, ECR Auth & Spring App Deployment

## Project Structure

```
.
├── main.tf
├── variables.tf
├── outputs.tf
├── userdata.sh
└── springapp.yaml
```

## variables.tf

```hcl
variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.medium"
}

variable "key_name" {
  description = "SSH key pair name"
  type        = string
}

variable "vpc_cidr" {
  description = "VPC CIDR block"
  type        = string
  default     = "10.0.0.0/16"
}

variable "subnet_cidr" {
  description = "Subnet CIDR block"
  type        = string
  default     = "10.0.1.0/24"
}

variable "allowed_ssh_cidr" {
  description = "CIDR block allowed for SSH access"
  type        = string
  default     = "0.0.0.0/0"
}

variable "ecr_repository_name" {
  description = "Name of the ECR repository for the Spring app"
  type        = string
  default     = "springapp"
}

variable "spring_app_image_tag" {
  description = "Docker image tag for the Spring application"
  type        = string
  default     = "latest"
}

variable "ami_id" {
  description = "AMI ID for the EC2 instance (Ubuntu 22.04). Leave empty to auto-detect."
  type        = string
  default     = ""
}
```

## main.tf

```hcl
terraform {
  required_version = ">= 1.3.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

# -------------------------------------------------------
# Data Sources
# -------------------------------------------------------

data "aws_caller_identity" "current" {}

data "aws_availability_zones" "available" {
  state = "available"
}

# Auto-detect latest Ubuntu 22.04 AMI if not provided
data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"] # Canonical

  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"]
  }

  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
}

locals {
  ami_id     = var.ami_id != "" ? var.ami_id : data.aws_ami.ubuntu.id
  account_id = data.aws_caller_identity.current.account_id
  ecr_url    = "${local.account_id}.dkr.ecr.${var.aws_region}.amazonaws.com"
}

# -------------------------------------------------------
# VPC & Networking
# -------------------------------------------------------

resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_support   = true
  enable_dns_hostnames = true

  tags = {
    Name = "k8s-springapp-vpc"
  }
}

resource "aws_internet_gateway" "igw" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = "k8s-springapp-igw"
  }
}

resource "aws_subnet" "public" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = var.subnet_cidr
  availability_zone       = data.aws_availability_zones.available.names[0]
  map_public_ip_on_launch = true

  tags = {
    Name = "k8s-springapp-public-subnet"
  }
}

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.igw.id
  }

  tags = {
    Name = "k8s-springapp-public-rt"
  }
}

resource "aws_route_table_association" "public" {
  subnet_id      = aws_subnet.public.id
  route_table_id = aws_route_table.public.id
}

# -------------------------------------------------------
# Security Group
# -------------------------------------------------------

resource "aws_security_group" "k8s_sg" {
  name_prefix = "k8s-springapp-sg"
  vpc_id      = aws_vpc.main.id
  description = "Security group for K8s EC2 instance"

  # SSH
  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = [var.allowed_ssh_cidr]
    description = "SSH access"
  }

  # Kubernetes API Server
  ingress {
    from_port   = 6443
    to_port     = 6443
    protocol    = "tcp"
    cidr_blocks = [var.allowed_ssh_cidr]
    description = "Kubernetes API Server"
  }

  # NodePort range
  ingress {
    from_port   = 30000
    to_port     = 32767
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Kubernetes NodePort services"
  }

  # HTTP
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "HTTP"
  }

  # HTTPS
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "HTTPS"
  }

  # Spring App default port
  ingress {
    from_port   = 8080
    to_port     = 8080
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Spring Boot app"
  }

  # All outbound
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "All outbound traffic"
  }

  tags = {
    Name = "k8s-springapp-sg"
  }
}

# -------------------------------------------------------
# IAM Role for EC2 (ECR Access)
# -------------------------------------------------------

resource "aws_iam_role" "ec2_k8s_role" {
  name = "ec2-k8s-ecr-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ec2.amazonaws.com"
        }
      }
    ]
  })

  tags = {
    Name = "ec2-k8s-ecr-role"
  }
}

resource "aws_iam_role_policy" "ecr_policy" {
  name = "ecr-access-policy"
  role = aws_iam_role.ec2_k8s_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "ecr:GetAuthorizationToken",
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer",
          "ecr:BatchCheckLayerAvailability",
          "ecr:PutImage",
          "ecr:InitiateLayerUpload",
          "ecr:UploadLayerPart",
          "ecr:CompleteLayerUpload",
          "ecr:DescribeRepositories",
          "ecr:ListImages",
          "ecr:DescribeImages",
          "ecr:CreateRepository"
        ]
        Resource = "*"
      }
    ]
  })
}

resource "aws_iam_instance_profile" "ec2_k8s_profile" {
  name = "ec2-k8s-ecr-instance-profile"
  role = aws_iam_role.ec2_k8s_role.name
}

# -------------------------------------------------------
# ECR Repository
# -------------------------------------------------------

resource "aws_ecr_repository" "springapp" {
  name                 = var.ecr_repository_name
  image_tag_mutability = "MUTABLE"
  force_delete         = true

  image_scanning_configuration {
    scan_on_push = true
  }

  tags = {
    Name = "springapp-ecr"
  }
}

# -------------------------------------------------------
# EC2 Instance
# -------------------------------------------------------

resource "aws_instance" "k8s_node" {
  ami                    = local.ami_id
  instance_type          = var.instance_type
  key_name               = var.key_name
  subnet_id              = aws_subnet.public.id
  vpc_security_group_ids = [aws_security_group.k8s_sg.id]
  iam_instance_profile   = aws_iam_instance_profile.ec2_k8s_profile.name

  root_block_device {
    volume_size = 30
    volume_type = "gp3"
    encrypted   = true
  }

  user_data = templatefile("${path.module}/userdata.sh", {
    aws_region       = var.aws_region
    ecr_url          = local.ecr_url
    ecr_repo         = aws_ecr_repository.springapp.repository_url
    image_tag        = var.spring_app_image_tag
    account_id       = local.account_id
    ecr_repo_name    = var.ecr_repository_name
  })

  tags = {
    Name = "k8s-springapp-node"
  }

  # Give enough time for userdata to complete
  timeouts {
    create = "30m"
  }
}
```

## userdata.sh

```bash
#!/bin/bash
set -euxo pipefail

# Log everything to a file for debugging
exec > >(tee /var/log/userdata.log) 2>&1
echo "=== UserData script started at $(date) ==="

export DEBIAN_FRONTEND=noninteractive
export AWS_REGION="${aws_region}"
export ECR_URL="${ecr_url}"
export ECR_REPO="${ecr_repo}"
export IMAGE_TAG="${image_tag}"
export ACCOUNT_ID="${account_id}"
export ECR_REPO_NAME="${ecr_repo_name}"

# -------------------------------------------------------
# 1. System Preparation
# -------------------------------------------------------
echo "=== Updating system packages ==="
apt-get update -y
apt-get upgrade -y
apt-get install -y \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg \
    lsb-release \
    software-properties-common \
    unzip \
    git \
    jq \
    socat \
    conntrack

# -------------------------------------------------------
# 2. Install AWS CLI v2
# -------------------------------------------------------
echo "=== Installing AWS CLI v2 ==="
curl -fsSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip"
cd /tmp && unzip -o awscliv2.zip
./aws/install --update
aws --version

# -------------------------------------------------------
# 3. Disable swap (required for Kubernetes)
# -------------------------------------------------------
echo "=== Disabling swap ==="
swapoff -a
sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab

# -------------------------------------------------------
# 4. Load kernel modules & configure sysctl
# -------------------------------------------------------
echo "=== Configuring kernel modules and sysctl ==="
cat <<EOF | tee /etc/modules-load.d/k8s.conf
overlay
br_netfilter
EOF

modprobe overlay
modprobe br_netfilter

cat <<EOF | tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF

sysctl --system

# -------------------------------------------------------
# 5. Install containerd
# -------------------------------------------------------
echo "=== Installing containerd ==="

# Add Docker's official GPG key and repo (for containerd)
install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \
    gpg --dearmor -o /etc/apt/keyrings/docker.gpg
chmod a+r /etc/apt/keyrings/docker.gpg

echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | \
    tee /etc/apt/sources.list.d/docker.list > /dev/null

apt-get update -y
apt-get install -y containerd.io docker-ce docker-ce-cli

# Configure containerd to use systemd cgroup driver
mkdir -p /etc/containerd
containerd config default | tee /etc/containerd/config.toml
sed -i 's/SystemdCgroup = false/SystemdCgroup = true/g' /etc/containerd/config.toml

systemctl restart containerd
systemctl enable containerd

# Enable and start Docker (needed for building images)
systemctl enable docker
systemctl start docker

# -------------------------------------------------------
# 6. Install Kubernetes (kubeadm, kubelet, kubectl)
# -------------------------------------------------------
echo "=== Installing Kubernetes components ==="

# Add Kubernetes apt repo (v1.29)
KUBE_VERSION="1.29"
curl -fsSL "https://pkgs.k8s.io/core:/stable:/v$${KUBE_VERSION}/deb/Release.key" | \
    gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg

echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] \
https://pkgs.k8s.io/core:/stable:/v$${KUBE_VERSION}/deb/ /" | \
    tee /etc/apt/sources.list.d/kubernetes.list

apt-get update -y
apt-get install -y kubelet kubeadm kubectl
apt-mark hold kubelet kubeadm kubectl

systemctl enable kubelet

# -------------------------------------------------------
# 7. Initialize Kubernetes cluster (single-node)
# -------------------------------------------------------
echo "=== Initializing Kubernetes cluster ==="

PRIVATE_IP=$(curl -s http://169.254.169.254/latest/meta-data/local-ipv4)
PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4 || echo "")

kubeadm init \
    --pod-network-cidr=10.244.0.0/16 \
    --apiserver-advertise-address="$PRIVATE_IP" \
    --apiserver-cert-extra-sans="$PRIVATE_IP,$PUBLIC_IP" \
    --node-name="$(hostname)"

# Configure kubectl for root user
mkdir -p /root/.kube
cp -f /etc/kubernetes/admin.conf /root/.kube/config
chown root:root /root/.kube/config
export KUBECONFIG=/root/.kube/config

# Configure kubectl for ubuntu user
mkdir -p /home/ubuntu/.kube
cp -f /etc/kubernetes/admin.conf /home/ubuntu/.kube/config
chown ubuntu:ubuntu /home/ubuntu/.kube/config

# -------------------------------------------------------
# 8. Install Flannel CNI
# -------------------------------------------------------
echo "=== Installing Flannel CNI ==="
kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml

# -------------------------------------------------------
# 9. Remove control-plane taint (single-node cluster)
# -------------------------------------------------------
echo "=== Removing control-plane taint for single-node scheduling ==="
sleep 10
kubectl taint nodes --all node-role.kubernetes.io/control-plane- || true

# Wait for node to be ready
echo "=== Waiting for node to be Ready ==="
for i in $(seq 1 60); do
    NODE_STATUS=$(kubectl get nodes -o jsonpath='{.items[0].status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "Unknown")
    if [ "$NODE_STATUS" = "True" ]; then
        echo "Node is Ready!"
        break
    fi
    echo "Waiting for node... ($i/60)"
    sleep 10
done

kubectl get nodes -o wide

# -------------------------------------------------------
# 10. Authenticate to ECR
# -------------------------------------------------------
echo "=== Authenticating to ECR ==="

# Login Docker to ECR
aws ecr get-login-password --region "$AWS_REGION" | \
    docker login --username AWS --password-stdin "$ECR_URL"

# -------------------------------------------------------
# 11. Clone repo, build Docker image, push to ECR
# -------------------------------------------------------
echo "=== Cloning Spring App repository ==="
cd /tmp
git clone https://github.com/tlh2857-2024/springapp.git
cd springapp

# Check if Dockerfile exists; if not create one
if [ ! -f Dockerfile ]; then
    echo "=== Creating Dockerfile for Spring Boot app ==="
    cat <<'DOCKERFILE' > Dockerfile
FROM maven:3.9-eclipse-temurin-17 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests

FROM eclipse-temurin:17-jre
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
DOCKERFILE
fi

echo "=== Building Docker image ==="
docker build -t "$ECR_REPO_NAME:$IMAGE_TAG" .

echo "=== Tagging and pushing image to ECR ==="
docker tag "$ECR_REPO_NAME:$IMAGE_TAG" "$ECR_REPO:$IMAGE_TAG"
docker push "$ECR_REPO:$IMAGE_TAG"

# -------------------------------------------------------
# 12. Create ECR pull secret in Kubernetes
# -------------------------------------------------------
echo "=== Creating ECR pull secret in Kubernetes ==="

ECR_TOKEN=$(aws ecr get-login-password --region "$AWS_REGION")

kubectl create secret docker-registry ecr-secret \
    --docker-server="$ECR_URL" \
    --docker-username=AWS \
    --docker-password="$ECR_TOKEN" \
    --namespace=default || true

# -------------------------------------------------------
# 13. Create ECR credential refresh CronJob
# -------------------------------------------------------
echo "=== Setting up ECR credential refresh cron ==="
cat <<'CRONSCRIPT' > /usr/local/bin/refresh-ecr-token.sh
#!/bin/bash
export KUBECONFIG=/root/.kube/config
export AWS_REGION="${aws_region}"
ECR_URL="${ecr_url}"

ECR_TOKEN=$(aws ecr get-login-password --region "$AWS_REGION")

kubectl delete secret ecr-secret --namespace=default --ignore-not-found
kubectl create secret docker-registry ecr-secret \
    --docker-server="$ECR_URL" \
    --docker-username=AWS \
    --docker-password="$ECR_TOKEN" \
    --namespace=default

# Also refresh docker login
echo "$ECR_TOKEN" | docker login --username AWS --password-stdin "$ECR_URL"
CRONSCRIPT

chmod +x /usr/local/bin/refresh-ecr-token.sh

# ECR tokens expire every 12 hours; refresh every 10 hours
(crontab -l 2>/dev/null; echo "0 */10 * * * /usr/local/bin/refresh-ecr-token.sh >> /var/log/ecr-refresh.log 2>&1") | crontab -

# -------------------------------------------------------
# 14. Deploy Spring App using springapp.yaml (or generate)
# -------------------------------------------------------
echo "=== Deploying Spring Application ==="

# Check if springapp.yaml exists in the repo
if [ -f /tmp/springapp/springapp.yaml ]; then
    echo "=== Found springapp.yaml in repo - updating image reference ==="
    # Replace image placeholder with actual ECR image
    sed -i "s|image:.*|image: $ECR_REPO:$IMAGE_TAG|g" /tmp/springapp/springapp.yaml
    # Add imagePullSecrets if not present
    if ! grep -q "imagePullSecrets" /tmp/springapp/springapp.yaml; then
        sed -i '/containers:/i\      imagePullSecrets:\n      - name: ecr-secret' /tmp/springapp/springapp.yaml
    fi
    cp /tmp/springapp/springapp.yaml /root/springapp.yaml
else
    echo "=== springapp.yaml not found in repo - generating deployment manifest ==="
    cat <<APPYAML > /root/springapp.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: springapp
  labels:
    app: springapp
spec:
  replicas: 2
  selector:
    matchLabels:
      app: springapp
  template:
    metadata:
      labels:
        app: springapp
    spec:
      imagePullSecrets:
      - name: ecr-secret
      containers:
      - name: springapp
        image: $ECR_REPO:$IMAGE_TAG
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 15
---
apiVersion: v1
kind: Service
metadata:
  name: springapp-service
spec:
  type: NodePort
  selector:
    app: springapp
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
    nodePort: 30080
APPYAML
fi

kubectl apply -f /root/springapp.yaml

# -------------------------------------------------------
# 15. Wait for deployment to roll out
# -------------------------------------------------------
echo "=== Waiting for Spring App deployment ==="
kubectl rollout status deployment/springapp --timeout=300s || true

echo "=== Deployment Status ==="
kubectl get deployments -o wide
kubectl get pods -o wide
kubectl get services -o wide

echo "=== UserData script completed at $(date) ==="
echo "=== Spring App should be accessible at http://<PUBLIC_IP>:30080 ==="
```

## outputs.tf

```hcl
output "instance_id" {
  description = "EC2 Instance ID"
  value       = aws_instance.k8s_node.id
}

output "instance_public_ip" {
  description = "Public IP of the EC2 instance"
  value       = aws_instance.k8s_node.public_ip
}

output "instance_public_dns" {
  description = "Public DNS of the EC2 instance"
  value       = aws_instance.k8s_node.public_dns
}

output "ecr_repository_url" {
  description = "ECR Repository URL"
  value       = aws_ecr_repository.springapp.repository_url
}

output "spring_app_url" {
  description = "URL to access the Spring application"
  value       = "http://${aws_instance.k8s_node.public_ip}:30080"
}

output "ssh_command" {
  description = "SSH command to connect to the instance"
  value       = "ssh -i <your-key>.pem ubuntu@${aws_instance.k8s_node.public_ip}"
}

output "kubectl_check_commands" {
  description = "Commands to check deployment status"
  value       = <<-EOT
    SSH into the instance and run:
      kubectl get nodes
      kubectl get pods -o wide
      kubectl get services
      kubectl logs -l app=springapp
      tail -f /var/log/userdata.log
  EOT
}
```

## How to Deploy

```bash
# 1. Initialize Terraform
terraform init

# 2. Review the plan
terraform plan -var="key_name=your-ssh-key-name"

# 3. Apply
terraform apply -var="key_name=your-ssh-key-name"

# 4. Wait ~10-15 minutes for userdata to complete

# 5. Check the outputs
terraform output

# 6. SSH in and check progress
ssh -i your-key.pem ubuntu@$(terraform output -raw instance_public_ip)
sudo tail -f /var/log/userdata.log

# 7. Verify the deployment
sudo kubectl get nodes
sudo kubectl get pods
sudo kubectl get svc

# 8. Access the app
curl http://$(terraform output -raw instance_public_ip):30080
```

## terraform.tfvars (example)

```hcl
aws_region           = "us-east-1"
instance_type        = "t3.medium"
key_name             = "my-ssh-key"
allowed_ssh_cidr     = "203.0.113.0/24"  # Your IP CIDR
ecr_repository_name  = "springapp"
spring_app_image_tag = "latest"
```

## Architecture Summary

```
┌─────────────────────────────────────────────────────────┐
│                        AWS VPC                          │
│                    (10.0.0.0/16)                        │
│                                                         │
│  ┌───────────────────────────────────────────────────┐  │
│  │              Public Subnet (10.0.1.0/24)          │  │
│  │                                                   │  │
│  │  ┌─────────────────────────────────────────────┐  │  │
│  │  │         EC2 Instance (t3.medium)            │  │  │
│  │  │                                             │  │  │
│  │  │  ┌───────────────────────────────────────┐  │  │  │
│  │  │  │   Kubernetes (kubeadm single-node)    │  │  │  │
│  │  │  │                                       │  │  │  │
│  │  │  │  ┌─────────┐    ┌──────────────────┐ │  │  │  │
│  │  │  │  │ Flannel  │    │  Spring App Pod  │ │  │  │  │
│  │  │  │  │   CNI    │    │  (x2 replicas)   │ │  │  │  │
│  │  │  │  └─────────┘    └──────────────────┘ │  │  │  │
│  │  │  │                  │                    │  │  │  │
│  │  │  │           NodePort :30080             │  │  │  │
│  │  │  └───────────────────────────────────────┘  │  │  │
│  │  │                                             │  │  │
│  │  │  IAM Role → ECR Auth                        │  │  │
│  │  └─────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  ┌──────────────┐                                       │
│  │     ECR      │  ← Docker image: springapp:latest     │
│  │  Repository  │                                       │
│  └──────────────┘                                       │
└─────────────────────────────────────────────────────────┘
          │
    Internet Gateway
          │
    User → http://<public-ip>:30080
```

## Key Features

| Feature | Details |
|---|---|
| **Kubernetes** | Single-node cluster via kubeadm v1.29 with Flannel CNI |
| **Container Runtime** | containerd with systemd cgroup driver |
| **ECR Auth** | IAM instance profile + docker-registry secret in K8s |
| **Token Refresh** | Cron job every 10 hours to refresh ECR token (12hr expiry) |
| **Image Pipeline** | Clones repo → builds Docker image → pushes to ECR → deploys to K8s |
| **Networking** | Dedicated VPC, public subnet, security group with NodePort access |
| **Monitoring** | Full userdata log at `/var/log/userdata.log` |